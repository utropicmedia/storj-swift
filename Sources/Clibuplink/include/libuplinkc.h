/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package storj.io/storj/lib/uplinkc */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h> /* for ptrdiff_t below */

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
#endif

#endif

/* Start of preamble from import "C" comments.  */


#line 6 "access_scope.go"
 #include "uplink_definitions.h"

#line 1 "cgo-generated-wrapper"

#line 6 "apikey.go"
 #include "uplink_definitions.h"

#line 1 "cgo-generated-wrapper"

#line 6 "bucket.go"
 #include "uplink_definitions.h"

#line 1 "cgo-generated-wrapper"

#line 6 "encryption_access.go"
 #include "uplink_definitions.h"

#line 1 "cgo-generated-wrapper"

#line 6 "object.go"
 #include "uplink_definitions.h"

#line 1 "cgo-generated-wrapper"

#line 6 "project.go"
 #include "uplink_definitions.h"

#line 1 "cgo-generated-wrapper"

#line 6 "uplink.go"
 #include "uplink_definitions.h"

#line 1 "cgo-generated-wrapper"


/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef __SIZE_TYPE__ GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif


// new_scope creates new Scope

extern ScopeRef new_scope(char* p0, APIKeyRef p1, EncryptionAccessRef p2, char** p3);

// get_scope_satellite_address gets Scope satellite address

extern char* get_scope_satellite_address(ScopeRef p0, char** p1);

// get_scope_api_key gets Scope APIKey

extern APIKeyRef get_scope_api_key(ScopeRef p0, char** p1);

// get_scope_enc_access gets Scope encryption access

extern EncryptionAccessRef get_scope_enc_access(ScopeRef p0, char** p1);

// parse_scope parses an Scope

extern ScopeRef parse_scope(char* p0, char** p1);

// serialize_scope serializes the Scope to a string

extern char* serialize_scope(ScopeRef p0, char** p1);

// restrict_scope restricts a given scope with the provided caveat and encryption restrictions

extern ScopeRef restrict_scope(ScopeRef p0, Caveat p1, EncryptionRestriction** p2, size_t p3, char** p4);

// free_scope frees an scope

extern void free_scope(ScopeRef p0);

// parse_api_key parses an API Key

extern APIKeyRef parse_api_key(char* p0, char** p1);

// serialize_api_key serializes the API Key to a string

extern char* serialize_api_key(APIKeyRef p0, char** p1);

// free_api_key frees an api key

extern void free_api_key(APIKeyRef p0);

// create_bucket creates a new bucket if authorized.

extern BucketInfo create_bucket(ProjectRef p0, char* p1, BucketConfig* p2, char** p3);

// get_bucket_info returns info about the requested bucket if authorized.

extern BucketInfo get_bucket_info(ProjectRef p0, char* p1, char** p2);

// open_bucket returns a Bucket handle with the given encryption context information.

extern BucketRef open_bucket(ProjectRef p0, char* p1, char* p2, char** p3);

// list_buckets will list authorized buckets.

extern BucketList list_buckets(ProjectRef p0, BucketListOptions* p1, char** p2);

// delete_bucket deletes a bucket if authorized. If the bucket contains any
// Objects at the time of deletion, they may be lost permanently.

extern void delete_bucket(ProjectRef p0, char* p1, char** p2);

// close_bucket closes a Bucket handle.

extern void close_bucket(BucketRef p0, char** p1);

// free_bucket_info frees bucket info.

extern void free_bucket_info(BucketInfo* p0);

// free_bucket_list will free a list of buckets

extern void free_bucket_list(BucketList* p0);

// new_encryption_access creates an encryption access context

extern EncryptionAccessRef new_encryption_access(char** p0);

// new_encryption_access creates an encryption access context with a default key set.

extern EncryptionAccessRef new_encryption_access_with_default_key(uint8_t* p0);

// set_default_key sets the default key for the encryption access context.

extern void set_default_key(EncryptionAccessRef p0, uint8_t* p1, char** p2);

// serialize_encryption_access turns an encryption access into base58.

extern char* serialize_encryption_access(EncryptionAccessRef p0, char** p1);

// parse_encryption_access parses a base58 serialized encryption access into a working one.

extern EncryptionAccessRef parse_encryption_access(char* p0, char** p1);

extern void free_encryption_access(EncryptionAccessRef p0);

// open_object returns an Object handle, if authorized.

extern ObjectRef open_object(BucketRef p0, char* p1, char** p2);

// close_object closes the object.

extern void close_object(ObjectRef p0, char** p1);

// get_object_meta returns the object meta which contains metadata about a specific Object.

extern ObjectMeta get_object_meta(ObjectRef p0, char** p1);

// upload uploads a new object, if authorized.

extern UploaderRef upload(BucketRef p0, char* p1, UploadOptions* p2, char** p3);

extern size_t upload_write(UploaderRef p0, uint8_t* p1, size_t p2, char** p3);

extern void upload_commit(UploaderRef p0, char** p1);

extern void upload_cancel(UploaderRef p0, char** p1);

// list_objects lists objects a user is authorized to see.

extern ObjectList list_objects(BucketRef p0, ListOptions* p1, char** p2);

// download returns an Object's data. A length of -1 will mean
// (Object.Size - offset).

extern DownloaderRef download(BucketRef p0, char* p1, char** p2);

// download_range returns an Object's data from specified range

extern DownloaderRef download_range(BucketRef p0, char* p1, GoInt64 p2, GoInt64 p3, char** p4);

// download_read reads data upto `length` bytes into `bytes` buffer and returns
// the count of bytes read. The exact number of bytes returned depends on different
// buffers and what is currently available.
// When there is no more data available function returns 0.
// On an error cErr is set, however some data may still be returned.

extern size_t download_read(DownloaderRef p0, uint8_t* p1, size_t p2, char** p3);

extern void download_close(DownloaderRef p0, char** p1);

extern void download_cancel(DownloaderRef p0, char** p1);

extern void delete_object(BucketRef p0, char* p1, char** p2);

// free_uploader deletes the uploader reference from the universe

extern void free_uploader(UploaderRef p0);

// free_downloader deletes the downloader reference from the universe

extern void free_downloader(DownloaderRef p0);

extern void free_upload_opts(UploadOptions* p0);

// free_object_meta frees the object meta

extern void free_object_meta(ObjectMeta* p0);

// free_object_info frees the object info

extern void free_object_info(ObjectInfo* p0);

// free_list_objects frees the list of objects

extern void free_list_objects(ObjectList* p0);

// open_project opens project using uplink

extern ProjectRef open_project(UplinkRef p0, char* p1, APIKeyRef p2, char** p3);

// project_salted_key_from_passphrase returns a key generated from the given passphrase
// using a stable, project-specific salt

extern uint8_t* project_salted_key_from_passphrase(ProjectRef p0, char* p1, char** p2);

// close_project closes the project.

extern void close_project(ProjectRef p0, char** p1);

// internal_UniverseIsEmpty returns true if nothing is stored in the global map.

extern GoUint8 internal_UniverseIsEmpty();

// new_uplink creates the uplink with the specified configuration and returns
// an error in cerr, when there is one.
//
// Caller must call close_uplink to close associated resources.

extern UplinkRef new_uplink(UplinkConfig p0, char* p1, char** p2);

// close_uplink closes and frees the resources associated with uplink

extern void close_uplink(UplinkRef p0, char** p1);

#ifdef __cplusplus
}
#endif
